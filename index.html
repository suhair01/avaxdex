<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Arena DEX</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.6.2/dist/ethers.umd.min.js"></script>
  <style>
    body {
      background: #121212;
      color: white;
      font-family: sans-serif;
      margin: 0;
    }
    .container {
      max-width: 480px;
      margin: 40px auto;
      background: #1f1f1f;
      padding: 24px;
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0,0,0,0.4);
    }
    .token-box, .slippage-box {
      margin-bottom: 16px;
    }
    select, input {
      width: 100%;
      padding: 12px;
      margin-top: 6px;
      background: #2a2a2a;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
    }
    .btn {
      background-color: #00c2ff;
      color: white;
      padding: 12px;
      border: none;
      width: 100%;
      border-radius: 12px;
      font-size: 16px;
      cursor: pointer;
    }
    .info {
      margin-top: 12px;
      font-size: 14px;
      color: #ccc;
    }
  </style>
</head>
<body>
<div class="container">
  <h2>ðŸŽ¯ Arena DEX</h2>

  <div class="token-box">
    <label>From Token:</label>
    <select id="tokenInSelect"></select>
    <input id="fromAmount" placeholder="Amount" />
  </div>

  <div class="token-box">
    <label>To Token:</label>
    <select id="tokenOutSelect"></select>
    <div class="info" id="estimatedOut">Estimated: -</div>
  </div>

  <div class="slippage-box">
    <label>Slippage Tolerance (%):</label>
    <input id="slippage" value="1" />
  </div>

  <button class="btn" onclick="connect()">ðŸ”Œ Connect Wallet</button>
  <div class="info" id="walletStatus">Not connected</div>
  <button class="btn" onclick="swap()">ðŸ”¥ Swap</button>
</div>

<script>
const routerAddress = "0xF56D524D651B90E4B84dc2FffD83079698b9066E";

const routerAbi = [
  "function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)",
  "function getAmountsOut(uint amountIn, address[] calldata path) view returns (uint[] memory)"
];

const erc20Abi = [
  "function balanceOf(address) view returns (uint)",
  "function approve(address spender, uint256 value) returns (bool)",
  "function decimals() view returns (uint8)",
  "function symbol() view returns (string)",
  "function name() view returns (string)",
  "function allowance(address owner, address spender) view returns (uint256)"
];

let provider, signer, userAddress, router;
let tokens = [];

async function fetchTokensFromArenaFactory() {
  const factoryAbi = [
    "function allTokens(uint256) view returns (address)",
    "function allTokensLength() view returns (uint256)"
  ];

  const factory = new ethers.Contract(
    "0xF16784dcAf838a3e16bEF7711a62D12413c39BD1",
    factoryAbi,
    provider
  );

  const count = await factory.allTokensLength();
  tokens = [];

  for (let i = 0; i < count; i++) {
    const tokenAddress = await factory.allTokens(i);
    try {
      const token = new ethers.Contract(tokenAddress, erc20Abi, provider);
      const symbol = await token.symbol();
      const name = await token.name();
      const decimals = await token.decimals();
      tokens.push({ address: tokenAddress, symbol, name, decimals });
    } catch (err) {
      console.warn("Failed to fetch token at index", i);
    }
  }

  populateTokenDropdowns();
}

function populateTokenDropdowns() {
  const fromSel = document.getElementById("tokenInSelect");
  const toSel = document.getElementById("tokenOutSelect");
  fromSel.innerHTML = "";
  toSel.innerHTML = "";
  tokens.forEach(t => {
    const opt1 = document.createElement("option");
    opt1.value = t.address;
    opt1.text = t.symbol;
    fromSel.appendChild(opt1);

    const opt2 = document.createElement("option");
    opt2.value = t.address;
    opt2.text = t.symbol;
    toSel.appendChild(opt2);
  });
}

async function connect() {
  if (!window.ethereum) return alert("Install MetaMask or Rabby.");
  await window.ethereum.request({ method: "eth_requestAccounts" });
  provider = new ethers.BrowserProvider(window.ethereum);
  signer = await provider.getSigner();
  userAddress = await signer.getAddress();
  router = new ethers.Contract(routerAddress, routerAbi, signer);
  document.getElementById("walletStatus").innerText = "Connected: " + userAddress;
}

async function estimateOutput() {
  if (!router) return;
  const tokenIn = document.getElementById("tokenInSelect").value;
  const tokenOut = document.getElementById("tokenOutSelect").value;
  const amount = document.getElementById("fromAmount").value;
  if (!amount || tokenIn === tokenOut) return;

  try {
    const token = new ethers.Contract(tokenIn, erc20Abi, provider);
    const decimals = await token.decimals();
    const amountIn = ethers.parseUnits(amount, decimals);
    const amounts = await router.getAmountsOut(amountIn, [tokenIn, tokenOut]);
    const tokenOutContract = new ethers.Contract(tokenOut, erc20Abi, provider);
    const decimalsOut = await tokenOutContract.decimals();
    const estimated = ethers.formatUnits(amounts[1], decimalsOut);
    document.getElementById("estimatedOut").innerText = `Estimated: ~${estimated}`;
  } catch (err) {
    document.getElementById("estimatedOut").innerText = "Estimated: -";
  }
}

document.getElementById("fromAmount").addEventListener("input", estimateOutput);
document.getElementById("tokenInSelect").addEventListener("change", estimateOutput);
document.getElementById("tokenOutSelect").addEventListener("change", estimateOutput);

async function swap() {
  const tokenIn = document.getElementById("tokenInSelect").value;
  const tokenOut = document.getElementById("tokenOutSelect").value;
  const amount = document.getElementById("fromAmount").value;
  const slippage = parseFloat(document.getElementById("slippage").value);
  if (!amount || tokenIn === tokenOut) return alert("Invalid swap");

  try {
    const token = new ethers.Contract(tokenIn, erc20Abi, signer);
    const decimals = await token.decimals();
    const amountIn = ethers.parseUnits(amount, decimals);

    const allowance = await token.allowance(userAddress, routerAddress);
    if (allowance < amountIn) {
      const approveTx = await token.approve(routerAddress, ethers.MaxUint256);
      await approveTx.wait();
    }

    const amounts = await router.getAmountsOut(amountIn, [tokenIn, tokenOut]);
    const minOut = amounts[1] - (amounts[1] * BigInt(Math.floor(slippage * 100)) / 10000n);

    const tx = await router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
      amountIn,
      minOut,
      [tokenIn, tokenOut],
      userAddress,
      Math.floor(Date.now() / 1000) + 600
    );
    alert("Swap sent: " + tx.hash);
  } catch (err) {
    alert("Swap failed: " + err.message);
  }
}

fetchTokensFromArenaFactory();
</script>
</body>
</html>

